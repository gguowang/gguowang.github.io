<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Psych1&#39;s Blog</title>
  
  <subtitle>功不唐捐 玉汝于成</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.psych1.cn/"/>
  <updated>2020-08-04T15:17:52.233Z</updated>
  <id>https://www.psych1.cn/</id>
  
  <author>
    <name>psych1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Activity生命周期</title>
    <link href="https://www.psych1.cn/post/16237.html"/>
    <id>https://www.psych1.cn/post/16237.html</id>
    <published>2020-08-04T01:00:00.000Z</published>
    <updated>2020-08-04T15:17:52.233Z</updated>
    
    <content type="html"><![CDATA[<p>先放上Android API官方图镇楼。<br><img data-src="https://img-blog.csdnimg.cn/2019031714565797.gif" alt="oncreate()-&gt;onstart()-&gt;onResume()-&gt;onRestart()-&gt;onPouse()-&gt;onStop()-&gt;onDestory()"><br>oncreate()-&gt;onstart()-&gt;onResume()-&gt;onRestart()-&gt;onPouse()-&gt;onStop()-&gt;onDestory()</p><a id="more"></a><h2 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h2><p>1 运行状态<br>当一个 Activity 处于前台时，即处于栈顶时，它是活动或者运行的状态。<br>2 暂停状态<br>当一个 Activity 失去焦点但仍然可见时，该 Activity 处于暂停状态（例如，在一个 Activity 上弹出一个对话框，该对话框并不铺满屏幕，原先的 Activity仍然被用户能看到）。一个处于暂停状态的 Activity 仍然是完全存活的（它会保存之前的状态和成员变量），但在内存极低的情况下会被系统杀死。<br>3 停止状态<br>但一个 Activity 完全被另一个 Activity 隐藏时，该 Activity 处于停止状态（即该 Activity 不再处于栈顶，并且不对用户来说可见时）。处于停止状态的 Activity 会保存之前的状态和成员变量，但在系统内存不够时，有可能被系统杀死（这种概率比处于暂停状态的 Activity 高）。<br>4 销毁状态<br>当一个 Activity 被移出返回栈时，它就处于销毁状态。处于销毁状态的 Activity 最有可能被系统回收。</p><h2 id="Activity的七个回调方法"><a href="#Activity的七个回调方法" class="headerlink" title="Activity的七个回调方法"></a>Activity的七个回调方法</h2><p>1 onCreate:create表示创建，这是Activity生命周期的第一个方法，也是我们在android开发中接触的最多的生命周期方法。它本身的作用是进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。但也有很多人将很多与初始化无关的代码放在这，其实这是不规范的。此时Activity还在后台，不可见。所以动画不应该在这里初始化，因为看不到……<br>2 onStart:start表示启动，这是Activity生命周期的第二个方法。此时Activity已经可见了，但是还没出现在前台，我们还看不到，无法与Activity交互。其实将Activity的初始化工作放在这也没有什么问题，放在onCreate中是由于官方推荐的以及我们开发的习惯。<br>3 onResume:resume表示继续、重新开始，这名字和它的职责也相同。此时Activity经过前两个阶段的初始化已经蓄势待发。Activity在这个阶段已经出现在前台并且可见了。这个阶段可以打开独占设备<br>4 onPause:pause表示暂停，当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。此时Activity在前台并可见，我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。从生命周期图中发现可以在这快速重启，但这种情况其实很罕见，比如用户切到下一个Activity的途中按back键快速得切回来。<br>5 onStop：stop表示停止，此时Activity已经不可见了，但是Activity对象还在内存中，没有被销毁。这个阶段的主要工作也是做一些资源的回收工作。<br>6 onDestroy：destroy表示毁灭，这个阶段Activity被销毁，不可见，我们可以将还没释放的资源释放，以及进行一些回收工作。<br>7 onRestart：restart表示重新开始，Activity在这时可见，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。这里一般不做什么操作。</p><h2 id="Activity的三个生存周期"><a href="#Activity的三个生存周期" class="headerlink" title="Activity的三个生存周期"></a>Activity的三个生存周期</h2><p>activity的三个生存周期，我们从上图也可以看的出来，主要介绍一下调用时间段。<br><strong>完整生存期</strong><br>Activity 的完整生存期是指在 <code>onCreate()</code> 方法第一次被调用和 <code>onDestroy()</code> 方法最后一次被调用之间的时间段；<br>应当在 <code>onCreate()</code> 方法内完成初始化操作， 并在 <code>onDestroy()</code> 方法内释放内存。<br><strong>可见生存期</strong><br>Activity 的可见生存期是指在 <code>onStart()</code> 方法被调用和 <code>onStop()</code> 方法被调用之间的时间段；<br>在可见生存期内，Activity 是可见的，即使该 Activity 不再前台和无法与用户交互；<br>在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 <code>onStart()</code> 方法和 <code>onStop()</code> 方法。<br><strong>前台生存期</strong><br>Activity 的前台生存期是指在 <code>onResume()</code> 方法被调用和 <code>onPause()</code> 方法被调用之间的时间段；<br>在前台生存期内，Activity 处于运行状态，位于屏幕上其他所有 Activity 之上，能与用户进行交互。</p><p>在这里重点需要关注的问题应该是Activity切换时的操作顺序。<br>(A)onPause→(B)onCreate→(B)onStart→(B)onResume→(A)onStop（正解）<br>(A)onPause→(A)onStop→(B)onCreate→(B)onStart→(B)onResume（错误）<br>（1）一个Activity或多或少会占有系统资源，而在官方的建议中，onPause方法将会释放掉很多系统资源，为切换Activity提供流畅性的保障，而不需要再等多两个阶段，这样做切换更快。<br>（2）按照生命周期图的表示，如果用户在切换Activity的过程中再次切回原Activity，是在onPause方法后直接调用onResume方法的，这样比onPause→onStop→onRestart→onStart→onResume要快得多。<br>举个例子来帮助记忆，当我们编辑完短信内容还没有发送，然后切换到桌面，这时短信内容并没有被销毁。<br>我们可以借助官方文档的代码，写一个demo帮助记忆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Activity extends ApplicationContext &#123;</span><br><span class="line">       protected void onCreate(Bundle savedInstanceState);</span><br><span class="line">       </span><br><span class="line">       protected void onStart();   </span><br><span class="line">       </span><br><span class="line">       protected void onRestart();</span><br><span class="line">       </span><br><span class="line">       protected void onResume();</span><br><span class="line">       </span><br><span class="line">       protected void onPause();</span><br><span class="line">       </span><br><span class="line">       protected void onStop();</span><br><span class="line">       </span><br><span class="line">       protected void onDestroy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们只需重写代码即可，参考log，即可更清楚的了解运行周期。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Android官方文档<br>《第一行代码》<br><a href="https://blog.csdn.net/android_tutor/article/details/5772285">https://blog.csdn.net/android_tutor/article/details/5772285</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先放上Android API官方图镇楼。&lt;br&gt;&lt;img data-src=&quot;https://img-blog.csdnimg.cn/2019031714565797.gif&quot; alt=&quot;oncreate()-&amp;gt;onstart()-&amp;gt;onResume()-&amp;gt;onRestart()-&amp;gt;onPouse()-&amp;gt;onStop()-&amp;gt;onDestory()&quot;&gt;&lt;br&gt;oncreate()-&amp;gt;onstart()-&amp;gt;onResume()-&amp;gt;onRestart()-&amp;gt;onPouse()-&amp;gt;onStop()-&amp;gt;onDestory()&lt;/p&gt;
    
    </summary>
    
    
      <category term="生命周期" scheme="https://www.psych1.cn/categories/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
    
      <category term="Android" scheme="https://www.psych1.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android反调试检测</title>
    <link href="https://www.psych1.cn/post/59192.html"/>
    <id>https://www.psych1.cn/post/59192.html</id>
    <published>2020-08-03T16:00:00.000Z</published>
    <updated>2020-08-04T15:17:52.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java层保护"><a href="#java层保护" class="headerlink" title="java层保护"></a>java层保护</h2><p><strong>1 代码混淆</strong><br>apk应用在被逆向分析时，java层代码就像被扒光一样，而native代码分析难度大，但是需要扎实的c/c++基础。这个时候大家就可以考虑一下代码混淆技术稍作保护（毕竟看着好多abc也挺烦的）。Android开发中提供了Proguard这一工具来进行代码混淆。<br>这里只做简单介绍，Proguard是一个开源项目，他能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。　</p><blockquote><ol><li>压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。</li><li>优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。</li><li>混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。</li><li>预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。</li></ol></blockquote><p>Proguard在Android Studio中都已经内置，每次新创建一个工程时，都会自动在gradle中被添加。</p><a id="more"></a><p><strong>2 调试器检测</strong><br>利用Java层API来判断Android程序是否是处于被调试下。进行动态调试的时候，需要进行jdb连接：jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700，当接连成功之后，android.os.Debug.isDebuggerConnected() 这个方法就会ture。这就跟系统的android.os.Debug.isDebuggerConnected()方法有关。解决也很简单，使用反编译工具方便程序，然后搜索isDebuggerConnected() 关键字， 然后Nop 掉改函数的调用即可。<br>还有就是判断当前应用属性：ApplicationInfo.FLAG_DEBUGGABLE。在反编译后AndroidMainfiest,xml 中添加：android：debuggable=”true”。</p><h2 id="native层"><a href="#native层" class="headerlink" title="native层"></a>native层</h2><p><strong>1 ptrace检测</strong><br>每个进程同时刻只能被1个调试进程ptrace，再次p自己会失败。所以可以主动ptrace自己,根据返回值判断自己是否被调试了；或者多进程ptrace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单线程ptrace</span><br><span class="line">void ptraceCheck()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; ptrace如果被调试返回值为-1，如果正常运行，返回值为0</span><br><span class="line">int iRet&#x3D;ptrace(PTRACE_TRACEME, 0, 0, 0);</span><br><span class="line">if(-1 &#x3D;&#x3D; iRet)</span><br><span class="line">&#123;</span><br><span class="line">LOGA(&quot;ptrace失败，进程正在被调试\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">LOGB(&quot;ptrace的返回值为:%d\n&quot;,iRet);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 进程名检测</strong><br>远程调试要在手机中运行android_server gdbserver gdb等进程，遍历进程，查找固定的进程名，如果能找到就说明调试器在运行。<br>有的时候不使用apk附加调试的方法进行逆向，而是写一个.out可执行文件直接加载so进行调试，这样程序的父进程名和正常启动apk的父进程名是不一样的。正常启动的apk程序父进程是zygote。如果不是，则证明为调试状态。<br>还有就是自身进程名，正常进程名一般是apk的com.xxx这样的格式。<br><strong>3 apk线程检测</strong><br>正常apk进程一般会有十几个线程在运行(比如会有jdwp线程)，自己写可执行文件加载so一般只有一个线程，可以根据这个差异来进行调试环境检测（咱们没用过，咱啥也不知道）。<br><strong>4 安卓系统调试检测函数</strong><br>这个跟上面有点重复。分析android自带调试检测函数isDebuggerConnected()在native的实现， 尝试在native使用。</p><blockquote><p>（1）dalvik模式下:<br> 找到进程中libdvm.so中的dvmDbgIsDebuggerConnected()函数，<br>调用他就能得知程序是否被调试。  dlopen(/system/lib/libdvm.so)<br>dlsym(_Z25dvmDbgIsDebuggerConnectedv)<br>（2）art模式下：<br>art模式下，结果存放在libart.so中的全局变量gDebuggerActive中，<br>符号名为_ZN3art3Dbg15gDebuggerActiveE。<br>但是貌似新版本android不允许使用非ndk原生库，dlopen(libart.so)会失败。  所以无法用dalvik那样的方法了。</p></blockquote><p><strong>5 轮询检测法</strong><br>轮询TracePid<br><img data-src="https://img-blog.csdnimg.cn/20190907150036608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个主要是参考了<a href="https://www.cnblogs.com/jiaoxiake/p/6790803.html%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%8E%BB%E4%BA%86%E8%A7%A3%E4%B8%8B%E3%80%82">https://www.cnblogs.com/jiaoxiake/p/6790803.html，可以进去了解下。</a></p><p><strong>6 断点检测</strong><br>如果函数被下软件断点，则断点地址会被改写为bkpt指令， 可以在函数体中搜索bkpt指令来检测软件断点。</p><pre><code>// IDA 6.8 断点扫描// 参数1：函数首地址 参数2：函数sizetypedef uint8_t u8;typedef uint32_t u32;void checkbkpt(u8* addr,u32 size)&#123;// 结果u32 uRet=0;// 断点指令// u8 armBkpt[4]=&#123;0xf0,0x01,0xf0,0xe7&#125;;// u8 thumbBkpt[2]=&#123;0x10,0xde&#125;;u8 armBkpt[4]=&#123;0&#125;;armBkpt[0]=0xf0;armBkpt[1]=0x01;armBkpt[2]=0xf0;armBkpt[3]=0xe7;u8 thumbBkpt[2]=&#123;0&#125;;thumbBkpt[0]=0x10;thumbBkpt[1]=0xde;// 判断模式int mode=(u32)addr%2;if(1==mode) &#123;LOGA(&quot;checkbkpt:(thumb mode)该地址为thumb模式\n&quot;);u8* start=(u8*)((u32)addr-1);u8* end=(u8*)((u32)start+size);// 遍历对比while(1)&#123;if(start &gt;= end) &#123;uRet=0;LOGA(&quot;checkbkpt:(no find bkpt)没有发现断点.\n&quot;);break;&#125;if( 0==memcmp(start,thumbBkpt,2) ) &#123;uRet=1;LOGA(&quot;checkbkpt:(find it)发现断点.\n&quot;);break;&#125;start=start+2;&#125;//while&#125;//ifelse&#123;LOGA(&quot;checkbkpt:(arm mode)该地址为arm模式\n&quot;);u8* start=(u8*)addr;u8* end=(u8*)((u32)start+size);// 遍历对比while(1) &#123;if (start &gt;= end) &#123;uRet = 0;LOGA(&quot;checkbkpt:(no find)没有发现断点.\n&quot;);break;&#125;if (0 == memcmp(start,armBkpt , 4))&#123;uRet = 1;LOGA(&quot;checkbkpt:(find it)发现断点.\n&quot;);break;&#125;start = start + 4;&#125;//while&#125;//elsereturn;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java层保护&quot;&gt;&lt;a href=&quot;#java层保护&quot; class=&quot;headerlink&quot; title=&quot;java层保护&quot;&gt;&lt;/a&gt;java层保护&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1 代码混淆&lt;/strong&gt;&lt;br&gt;apk应用在被逆向分析时，java层代码就像被扒光一样，而native代码分析难度大，但是需要扎实的c/c++基础。这个时候大家就可以考虑一下代码混淆技术稍作保护（毕竟看着好多abc也挺烦的）。Android开发中提供了Proguard这一工具来进行代码混淆。&lt;br&gt;这里只做简单介绍，Proguard是一个开源项目，他能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。　&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。&lt;/li&gt;
&lt;li&gt;优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。&lt;/li&gt;
&lt;li&gt;混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。&lt;/li&gt;
&lt;li&gt;预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Proguard在Android Studio中都已经内置，每次新创建一个工程时，都会自动在gradle中被添加。&lt;/p&gt;
    
    </summary>
    
    
      <category term="反调试" scheme="https://www.psych1.cn/categories/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="Android" scheme="https://www.psych1.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>android系统https抓包问题分析</title>
    <link href="https://www.psych1.cn/post/41193.html"/>
    <id>https://www.psych1.cn/post/41193.html</id>
    <published>2020-08-03T15:03:02.000Z</published>
    <updated>2020-08-04T15:17:52.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次分析app时都免不了抓包这一环节。想要抓到包就要看app采取的什么通信协议了。由于http存在的种种不安全性，当前大部分的app基本都已经是采用https的通信协议。所以连抓包也变得越来越不友好。不论是使用burpsuite还是fiddler，当前的抓包工具基本原理都是采用的中间人的方式。原理就是这些工具作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。</p><a id="more"></a><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>http即超文本传输协议，是互联网上应用最为广泛的一种网络协议 ，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。然而他也存在着一些缺点，比如通信使用明文，内容极易被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能遭到篡改。因此，http的加强版https应运而生。https中的s是ssl或者tls，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层。</p><blockquote><p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p></blockquote><p>https需要CA证书，我们之前说的中间人需要对客户端伪装成真正的服务端，要求就是当客户端向我们发送网络请求时，我们必须能够给指定域名签发公钥证书，且公钥证书能够通过系统的安全校验。对于我们是不是真正的客户端，通常来说服务器是不太会关心的，他是不会去关心你是谷歌浏览器还是百度浏览器，当然了也会有例外。接下来要说的双向验证就是如此。</p><h2 id="单向验证与双向验证"><a href="#单向验证与双向验证" class="headerlink" title="单向验证与双向验证"></a>单向验证与双向验证</h2><p>首先了解一下什么是https的单双向验证，主要说一下双向验证，双向验证相比较单向验证，增加了服务端对客户端的认证。<br><img data-src="https://img-blog.csdnimg.cn/20200315161339959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>双向认证详细过程如下：</p><blockquote><p>（1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。<br>（2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端<br>（3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥<br>（4）客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C_公钥<br>（5）客户端发送支持的对称加密方案给服务端，供其选择<br>（6）服务端选择完加密方案后，用刚才得到的C_公钥去加密选好的加密方案<br>（7）客户端用自己的C_私钥去解密选好的加密方案，客户端生成一个随机数（密钥F），用刚才等到的服务端B_公钥去加密这个随机数形成密文，发送给服务端。<br>（8）服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式</p></blockquote><p><img data-src="https://img-blog.csdnimg.cn/20200315164941104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="SSL-pinning"><a href="#SSL-pinning" class="headerlink" title="SSL pinning"></a>SSL pinning</h2><p>SSL Pinning是一种防止中间人攻击的技术，主要机制是在客户端发起请求–&gt;收到服务器发来的证书进行校验，如果收到的证书不被客户端信任，就直接断开连接不继续求情。可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。<br>SSL-pinning有两种方式：<br>证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。</p><blockquote><p>证书锁定<br>需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在<br>证书续期后需要将证书重新内置到APP中。</p><p>公钥锁定<br>提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。</p></blockquote><h2 id="双向验证与SSL-pinning的区别"><a href="#双向验证与SSL-pinning的区别" class="headerlink" title="双向验证与SSL pinning的区别"></a>双向验证与SSL pinning的区别</h2><p>一定要注意双向验证与SSL pinning的区别！<br>SSL pinning实际上是客户端锁定服务器端的证书, 在要与服务器进行交互的时候, 服务器端会将CA证书发送给客户端, 客户端会调用函数对服务器端的证书进行校验, 与本地的服务器端证书(存放在.\asset目录或\res\raw下)进行比对。而双向认证是添加了客户端向服务器发送CA证书, 服务器端对客户端的证书进行校验的部分。在app上，https双向认证的方案也可以防止中间人劫持，但这种双向认证开销较大，且安全性与SSL pinning一致，目前大多数app都采用SSL Pinning这种方案。</p><h2 id="突破双向认证抓包"><a href="#突破双向认证抓包" class="headerlink" title="突破双向认证抓包"></a>突破双向认证抓包</h2><p>由于私钥是受密码保护的，所以主要的逆向目标就是找到key–密码。看了好多表哥的文章，终于学会了一些奇淫巧计。由于当前的app都会有加壳混淆等等防护手段。所以可以到一些应用商店（如360手机助手，豌豆荚等等）下载应用的历史版本。低版本的保护不多分析难度相对较低。容易找到目标。<br>首先是到./assets目录下寻找证书。<br><img data-src="https://img-blog.csdnimg.cn/20200315175336931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>确实是有密码保护的。<br><img data-src="https://img-blog.csdnimg.cn/202003151753550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据证书名找到相关代码<br><img data-src="https://img-blog.csdnimg.cn/20200315180626874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20200315181056629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>继续往下看可以看到一些相关信息。<br><img data-src="https://img-blog.csdnimg.cn/20200315181604367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个getSocketFactory就是关键函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sSLContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">                InputStream open = context.getAssets().open(<span class="string">&quot;client.pfx&quot;</span>);</span><br><span class="line">                KeyStore instance = KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">                instance.load(open, toCharArray);</span><br><span class="line">                KeyManagerFactory instance2 = KeyManagerFactory.getInstance(<span class="string">&quot;X509&quot;</span>);</span><br><span class="line">                instance2.init(instance, toCharArray);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">char</span>[] toCharArray = EncryptUtils.getHttpSign(context).toCharArray();</span><br><span class="line">                <span class="keyword">if</span> (Arrays.hashCode(toCharArray) != -<span class="number">551029868</span>) &#123;</span><br><span class="line">                    s.d(<span class="string">&quot;pku %s is not valid&quot;</span>, <span class="keyword">new</span> Object[]&#123;Arrays.toString(toCharArray)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                sSLContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">                InputStream open = context.getAssets().open(<span class="string">&quot;client.pfx&quot;</span>);</span><br><span class="line">                KeyStore instance = KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">                instance.load(open, toCharArray);</span><br><span class="line">                KeyManagerFactory instance2 = KeyManagerFactory.getInstance(<span class="string">&quot;X509&quot;</span>);</span><br><span class="line">                instance2.init(instance, toCharArray);</span><br></pre></td></tr></table></figure><p>可以看到EncryptUtils函数。<br><img data-src="https://img-blog.csdnimg.cn/202003151826483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到native需要分析so层。进入so后<img data-src="https://img-blog.csdnimg.cn/2020031518342243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlX3BzeWNoZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密即可找到。<br>找到密码后，输入密码即可。</p><h2 id="使用xposed-hook绕过SSL证书验证"><a href="#使用xposed-hook绕过SSL证书验证" class="headerlink" title="使用xposed hook绕过SSL证书验证"></a>使用xposed hook绕过SSL证书验证</h2><p>在全球最大的同性交流网站某hub 下载<a href="https://github.com/Fuzion24/JustTrustMe/releases/tag/v.2">JustTrustMe</a><br>然后在xposed上安装这个框架就可以了。JustTrustMe的原理就是将各种已知的的HTTP请求库中用于校验证书的API都进行Hook，使无论是否是可信证书的情况，校验结果返回都为正常状态，从而实现绕过证书检查的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抓包是进行app逆向分析的第一步，走好每一步才能走向最后的成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每次分析app时都免不了抓包这一环节。想要抓到包就要看app采取的什么通信协议了。由于http存在的种种不安全性，当前大部分的app基本都已经是采用https的通信协议。所以连抓包也变得越来越不友好。不论是使用burpsuite还是fiddler，当前的抓包工具基本原理都是采用的中间人的方式。原理就是这些工具作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://www.psych1.cn/categories/%E6%8A%93%E5%8C%85/"/>
    
    
      <category term="Android" scheme="https://www.psych1.cn/tags/Android/"/>
    
  </entry>
  
</feed>
